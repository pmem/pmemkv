//
// Copyright 2019, Intel Corporation
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in
//       the documentation and/or other materials provided with the
//       distribution.
//
//     * Neither the name of the copyright holder nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// declare a map object for holding loaded libraries:
libs = [:]

currentBuild.displayName = "#$currentBuild.id $LABEL: $BRANCH - $TEST_TYPE, coverage: $COVERAGE"
currentBuild.description = "$DESCRIPTION"

PMEMKV_DIR='pmemkv'

//Send report summary via email.
def send_mail(attachments, msg) {

    def recipients = params.EMAIL_RECIPIENTS
    def message_title = "[Jenkins/pmemkv] Report ${currentBuild.projectName} ${currentBuild.displayName}"
    def message_body = """
        <p>---<br />Auto-generated by <a href="${env.JENKINS_URL}">Jenkins</a></p>
        <p><br /><a href="${env.JENKINS_URL}view/all/job/${currentBuild.projectName}/${currentBuild.id}">Build link</a></p>
        <p> <b> Description: </b> ${params.DESCRIPTION} </p>
    """

    message_body += msg

    emailext (
        to: recipients,
        subject: message_title,
        body: message_body,
        mimeType: "text/html",
        attachmentsPattern: attachments
    )
}

pipeline {
	// put timestamps in output log
	options { timestamps () }

	//execute tis pipeline job on node in "LABEL" group in Jenkins
	agent { label params.LABEL }

	//each stage represent pipeline step 
	stages {
		// preparation stage: clean workspace, create output directories, log file, clone repository containing Jenkins pipelines, load libraries, set warning on DUT and do other necessary preparatory stuff:
		stage('Prepare job') {
			steps {
				print "Deleting ${WORKSPACE} directory"
				deleteDir()

				print "Creating ${WORKSPACE}/output directory"
				dir('output') {
					writeFile file: 'console.log', text: ''
				}

				print "Checkout repository containing Jenkins pipelines"
				checkout([$class: 'GitSCM', branches: [[name: jenkins_files_branch]], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'jenkins_files']], submoduleCfg: [], userRemoteConfigs: [[url: jenkins_files_repo]]])

				print "Loading pipeline libraries"
				script {
					libs.api = load api_lib
					libs.api.set_jenkins_warning_on_dut()
				}
			}
		}
		// gather system info:
		stage('System-info'){
			steps {
				script {
					libs.api.system_info()
				}
			}
		}
		// clone PMEMKV repository:
		stage('Repository checkout: PMEMKV') {
			steps {
				script {
					def PMEMKV_PATH="${WORKSPACE_DIR}/${PMEMKV_DIR}"
					libs.api.clone_repository(params.REPO_URL, params.BRANCH, PMEMKV_DIR)
				}
			}
		}
		stage('Run test') {
			steps {
				script {
				warnError('Build unstable.') {
						def COV_PARAM=""
						if (params.COVERAGE == 'yes') {
								COV_PARAM="export COVERAGE=1"
							}
						def PMEMKV_PATH="${WORKSPACE_DIR}/${PMEMKV_DIR}"
						def ENV_VAL="export DEFAULT_TEST_DIR=/dev/shm; export WORKDIR=${PMEMKV_PATH}; export SCRIPTSDIR=\$WORKDIR/utils/docker; ${COV_PARAM}"
						print "TEST TYPE: $TEST_TYPE"
						switch (params.TEST_TYPE) {
							case 'normal':
								libs.api.run_bash_script("""
									${ENV_VAL}
									cd ${PMEMKV_PATH}/utils/docker
									./run-build.sh
								""")
								break;
							case 'building':
								libs.api.run_bash_script("""
									${ENV_VAL}
									cd ${PMEMKV_PATH}/utils/docker
									./run-test-building.sh
								""")
							case 'bindings':
								libs.api.run_bash_script("""
									${ENV_VAL}
									cd ${PMEMKV_PATH}/utils/docker
									./run-bindings.sh
								""")
							case 'compability':
								libs.api.run_bash_script("""
									${ENV_VAL}
									cd ${PMEMKV_PATH}/utils/docker
									./run-compatibility.sh
								""")
							case 'coverity':
								libs.api.run_bash_script("""
									${ENV_VAL}
									cd ${PMEMKV_PATH}/utils/docker
									./run-coverity.sh
								""")
							default:
								throw new java.lang.UnsupportedOperationException("TEST_TYPE value '${params.TEST_TYPE}' is not supported. Select: normal, building, bindings, compability or coverity.");
						}
					}
				}
			}
		}
	}
	// generate post-build artifacts
	// write "fail" or "success" in result.txt file
	// archive results
	post {
		//'always' declarations must be declared first.
		always {
			script {
				libs.api.unset_jenkins_warning_on_dut()
				libs.api.write_os_and_branch(params.LABEL, params.BRANCH)
				libs.api.archive_output()
				def PMEMKV_PATH="${WORKSPACE_DIR}/${PMEMKV_DIR}"
				libs.api.run_bash_script("""
							cd ${PMEMKV_PATH}/build || true
							sudo make unintall || true
						""")
			}
		}
		success {
			script {
				libs.api.write_result_and_archive('success')
				if (params.SEND_RESULTS) {
                    def build_info = "Build" + " #$currentBuild.id " + "succeeded"
                    send_mail('', build_info)
                }
			}
		}
		failure {
			script {
				libs.api.write_result_and_archive('fail')
				if (params.SEND_RESULTS) {
                    def build_info = "Build" + " #$currentBuild.id " + "failed"
                    send_mail('', build_info)
                }
			}
		}
		unstable {
			script {
				libs.api.write_result_and_archive('fail')
				if (params.SEND_RESULTS) {
                    def build_info = "Build" + " #$currentBuild.id " + "failed"
                    send_mail('', build_info)
                }
			}
		}
	}
}
